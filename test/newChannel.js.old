// cook mango twist then skin sort option civil have still rather guilt
/* globals artifacts, contract, web3, it, before, assert */
const abi = require("ethereumjs-abi");
const BigNumber = require("bignumber.js");

const test = require("blue-tape");
const p = require("util").promisify;
const SimpleToken = artifacts.require("./SimpleToken.sol");

const {
  ACCT_0_PRIVKEY,
  ACCT_1_PRIVKEY,
  ACCT_0_ADDR,
  ACCT_1_ADDR,
  ACCT_2_PRIVKEY,
  ACCT_2_ADDR,
  CHANNEL_STATUS
} = require("./constants.js");

const {
  openChannel,
  solSha3,
  sign,
  takeSnapshot,
  revertSnapshot,
  createTokens
} = require("./utils.js");

module.exports = async (test, channelManager) => {
  test("newChannel token happy path", async t => {
    const snapshot = await takeSnapshot();
    const simpleToken = await createTokens(SimpleToken);

    await openChannel(channelManager, ACCT_1_ADDR, 0, 6, 6000);

    t.equal((await simpleToken.balanceOf.call(ACCT_0_ADDR)).c[0], 4994);

    const activeId = await channelManager.activeIds.call(
      ACCT_0_ADDR,
      ACCT_1_ADDR
    );

    const channel = await channelManager.getChannel(activeId);

    t.deepEqual(JSON.parse(JSON.stringify(channel)), [
      ACCT_0_ADDR, // address agentA;
      ACCT_1_ADDR, // address agentB;
      simpleToken.address, // address tokenContract;
      6, // uint depositA;
      0, // uint depositB;
      CHANNEL_STATUS.OPEN, // ChannelStatus status;
      6000, // uint challenge;
      0, // uint nonce;
      0, // uint closeTime;
      0, // uint balanceA; // for state update
      6, // uint balanceB; // for state update
      0 // address challengeStartedBy; // for fast close
    ]);
    await revertSnapshot(snapshot);
  });

  /*   test("newChannel bad sig", async t => {
    const snapshot = await takeSnapshot();
    const channelId =
      "0x1000000000000000000000000000000000000000000000000000000000000000";

    await instance.depositToAddress.sendTransaction(ACCT_0_ADDR, { value: 12 });
    await instance.depositToAddress.sendTransaction(ACCT_1_ADDR, { value: 12 });

    const fingerprint = solSha3(
      "newChannel derp",
      channelId,
      ACCT_0_ADDR,
      ACCT_1_ADDR,
      6,
      6,
      2
    );

    const signature0 = sign(fingerprint, new Buffer(ACCT_0_PRIVKEY, "hex"));
    const signature1 = sign(fingerprint, new Buffer(ACCT_1_PRIVKEY, "hex"));

    await t.shouldFail(
      instance.newChannel(
        channelId,
        ACCT_0_ADDR,
        ACCT_1_ADDR,
        6,
        6,
        2,
        signature0,
        signature1
      )
    );

    await revertSnapshot(snapshot);
  });

  test("newChannel bad amount", async t => {
    const snapshot = await takeSnapshot();
    const channelId =
      "0x1000000000000000000000000000000000000000000000000000000000000000";

    await t.shouldFail(createChannel(instance, channelId, 6, 130, 2));
    await revertSnapshot(snapshot);
  });

  test("newChannel already exists", async t => {
    const snapshot = await takeSnapshot();
    const channelId =
      "0x1000000000000000000000000000000000000000000000000000000000000000";

    await createChannel(instance, channelId, 6, 6, 2);

    await t.shouldFail(createChannel(instance, channelId, 6, 6, 2));
    await revertSnapshot(snapshot);
  });

  test("newChannel wrong private key", async t => {
    const snapshot = await takeSnapshot();
    const channelId =
      "0x1000000000000000000000000000000000000000000000000000000000000000";

    await instance.depositToAddress.sendTransaction(ACCT_0_ADDR, { value: 12 });
    await instance.depositToAddress.sendTransaction(ACCT_1_ADDR, { value: 12 });

    const fingerprint = solSha3(
      "newChannel",
      channelId,
      ACCT_0_ADDR,
      ACCT_1_ADDR,
      6,
      6,
      2
    );

    const signature0 = sign(fingerprint, new Buffer(ACCT_0_PRIVKEY, "hex"));
    const signature1 = sign(fingerprint, new Buffer(ACCT_2_PRIVKEY, "hex"));

    await t.shouldFail(
      instance.newChannel(
        channelId,
        ACCT_0_ADDR,
        ACCT_1_ADDR,
        6,
        6,
        2,
        signature0,
        signature1
      )
    );
    await revertSnapshot(snapshot);
  });

  test("newChannel wrong public key", async t => {
    const snapshot = await takeSnapshot();
    const channelId =
      "0x1000000000000000000000000000000000000000000000000000000000000000";

    await instance.depositToAddress.sendTransaction(ACCT_0_ADDR, { value: 12 });
    await instance.depositToAddress.sendTransaction(ACCT_1_ADDR, { value: 12 });

    const fingerprint = solSha3(
      "newChannel",
      channelId,
      ACCT_0_ADDR,
      ACCT_1_ADDR,
      6,
      6,
      2
    );

    const signature0 = sign(fingerprint, new Buffer(ACCT_0_PRIVKEY, "hex"));
    const signature1 = sign(fingerprint, new Buffer(ACCT_1_PRIVKEY, "hex"));

    await t.shouldFail(
      instance.newChannel(
        channelId,
        ACCT_0_ADDR,
        ACCT_2_ADDR,
        6,
        6,
        2,
        signature0,
        signature1
      )
    );
    await revertSnapshot(snapshot);
  });
 */
};
